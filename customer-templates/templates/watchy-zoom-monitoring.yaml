AWSTemplateFormatVersion: '2010-09-09'
Description: 'Watchy Zoom Status Monitoring - Nuitka Binary Implementation'

Parameters:
  # ===== STANDARDIZED PARAMETERS FROM PARENT =====
  SaasAppName:
    Type: String
    Default: 'Zoom'
    Description: 'Name of the SaaS application'

  ApiUrl:
    Type: String
    Description: 'Zoom Status API endpoint URL'

  MonitoringSchedule:
    Type: String
    Description: 'Schedule expression for monitoring frequency'

  ApiKeysParameter:
    Type: String
    Description: 'ARN of the API keys parameter from parent stack'

  SharedLambdaRoleArn:
    Type: String
    Description: 'ARN of the shared Lambda execution role from parent stack'

  NotificationTopicArn:
    Type: String
    Description: 'ARN of the shared SNS topic for notifications'

  ParentStackName:
    Type: String
    Description: 'Name of the parent platform stack'

  BinaryDistributionUrl:
    Type: String
    Description: 'Base URL for Nuitka binary distribution'

  BinaryName:
    Type: String
    Default: 'watchy-zoom-monitor'
    Description: 'Name of the Zoom monitoring Nuitka binary'

  LogLevel:
    Type: String
    Default: 'INFO'
    Description: 'Log level for monitoring'

  TimeoutSeconds:
    Type: Number
    Default: 240
    Description: 'Timeout for monitoring operations'

  RetryAttempts:
    Type: Number
    Default: 3
    Description: 'Number of retry attempts'

Resources:
  # ===== ZOOM MONITORING LAMBDA =====
  ZoomMonitoringLambda:
    Type: AWS::Lambda::Function
    Properties:
      Architectures:
        - x86_64
      Description: 'Watchy Zoom status monitoring with Nuitka native binary'
      FunctionName: !Sub '${ParentStackName}-ZoomMonitor'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !Ref SharedLambdaRoleArn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          # Zoom-specific configuration
          SAAS_APP_NAME: !Ref SaasAppName
          API_URL: !Ref ApiUrl
          CLOUDWATCH_NAMESPACE: !Sub 'Watchy/${SaasAppName}'
          
          # Platform configuration
          API_KEYS_PARAMETER: !Ref ApiKeysParameter
          NOTIFICATION_TOPIC_ARN: !Ref NotificationTopicArn
          
          # Binary configuration
          WATCHY_BINARY_DISTRIBUTION_URL: !Ref BinaryDistributionUrl
          WATCHY_BINARY_NAME: !Ref BinaryName
          
          # Runtime configuration
          WATCHY_LOG_LEVEL: !Ref LogLevel
          WATCHY_TIMEOUT_SECONDS: !Ref TimeoutSeconds
          WATCHY_RETRY_ATTEMPTS: !Ref RetryAttempts
          WATCHY_STACK_NAME: !Ref ParentStackName
      Code:
        ZipFile: |
          import json
          import subprocess
          import os
          import logging
          import urllib.request
          import time
          import hashlib
          import stat
          import boto3
          import gzip
          from datetime import datetime

          logger = logging.getLogger()
          logger.setLevel(getattr(logging, os.environ.get('WATCHY_LOG_LEVEL', 'INFO')))

          _binary_cache = {}

          def get_nuitka_binary_info():
              """Get Zoom Nuitka binary information"""
              try:
                  base_url = os.environ.get('WATCHY_BINARY_DISTRIBUTION_URL')
                  info_url = f"{base_url}/binaries/zoom-monitor/metadata.json"
                  
                  with urllib.request.urlopen(info_url, timeout=10) as response:
                      if response.status == 200:
                          return json.loads(response.read().decode('utf-8'))
                  return None
              except Exception as e:
                  logger.error(f"Failed to get Zoom binary info: {e}")
                  return None

          def ensure_nuitka_binary():
              """Ensure we have the latest Nuitka binary with intelligent caching"""
              try:
                  binary_path = "/tmp/watchy-zoom-monitor"
                  cache_info_path = "/tmp/watchy-zoom-cache.json"
                  
                  # Get latest binary information
                  latest_info = get_nuitka_binary_info()
                  if not latest_info:
                      raise Exception("Failed to get binary information")
                  
                  # Check if we have cached binary info
                  cached_info = None
                  if os.path.exists(cache_info_path):
                      try:
                          with open(cache_info_path, 'r') as f:
                              cached_info = json.loads(f.read())
                      except:
                          cached_info = None
                  
                  # Check if binary exists and versions match
                  if (cached_info and 
                      os.path.exists(binary_path) and 
                      cached_info.get('version') == latest_info['version'] and
                      cached_info.get('sha256') == latest_info['sha256']):
                      
                      logger.info(f"‚úÖ Using cached Zoom binary v{latest_info['version']} (size: {cached_info.get('binarySize', 'unknown')} bytes)")
                      return binary_path, latest_info['version']
                  
                  # Download new binary
                  logger.info(f"üîÑ Downloading updated Zoom binary v{latest_info['version']}")
                  binary_path = download_zoom_binary(latest_info)
                  
                  # Cache the binary info
                  try:
                      with open(cache_info_path, 'w') as f:
                          json.dump({
                              'version': latest_info['version'],
                              'sha256': latest_info['sha256'],
                              'binarySize': latest_info.get('binarySize'),
                              'cached_at': time.time(),
                              'cache_date': datetime.utcnow().isoformat()
                          }, f)
                      logger.info(f"üíæ Cached binary info for future use")
                  except Exception as e:
                      logger.warning(f"Failed to cache binary info: {e}")
                  
                  return binary_path, latest_info['version']
                  
              except Exception as e:
                  logger.error(f"Failed to ensure binary: {e}")
                  raise

          def download_zoom_binary(binary_info):
              """Download Zoom monitoring Nuitka binary"""
              try:
                  binary_path = "/tmp/watchy-zoom-monitor"
                  
                  logger.info(f"Downloading Zoom Nuitka binary v{binary_info['version']}")
                  
                  with urllib.request.urlopen(binary_info['latestUrl'], timeout=120) as response:
                      if response.status != 200:
                          raise Exception(f"Download failed: HTTP {response.status}")
                      
                      if binary_info.get('compression') == 'gzip':
                          binary_data = gzip.decompress(response.read())
                      else:
                          binary_data = response.read()
                  
                  with open(binary_path, 'wb') as f:
                      f.write(binary_data)
                  
                  os.chmod(binary_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
                  
                  # Verify checksum by reading the file from disk
                  if binary_info.get('sha256'):
                      with open(binary_path, 'rb') as f:
                          file_data = f.read()
                      actual_hash = hashlib.sha256(file_data).hexdigest()
                      if actual_hash != binary_info['sha256']:
                          os.remove(binary_path)
                          logger.error(f"Expected SHA256: {binary_info['sha256']}")
                          logger.error(f"Actual SHA256: {actual_hash}")
                          raise Exception("Zoom binary checksum mismatch")
                  
                  logger.info("‚úÖ Zoom Nuitka binary ready")
                  return binary_path
                  
              except Exception as e:
                  logger.error(f"Zoom binary download failed: {e}")
                  raise

          def lambda_handler(event, context):
              """Zoom monitoring handler with intelligent binary caching"""
              start_time = time.time()
              
              try:
                  logger.info("üöÄ Starting Zoom status monitoring...")
                  
                  # Ensure we have the latest Zoom binary (with intelligent caching)
                  binary_path, version = ensure_nuitka_binary()
                  
                  # Load credentials
                  ssm = boto3.client('ssm')
                  
                  api_keys_response = ssm.get_parameter(
                      Name=os.environ.get('API_KEYS_PARAMETER'),
                      WithDecryption=True
                  )
                  api_keys = json.loads(api_keys_response['Parameter']['Value'])
                  
                  # Prepare environment for Zoom binary
                  env = os.environ.copy()
                  env['ZOOM_API_KEY'] = api_keys.get('zoom_api_key', '')
                  env['ZOOM_API_SECRET'] = api_keys.get('zoom_api_secret', '')
                  env['WATCHY_AWS_REQUEST_ID'] = context.aws_request_id
                  env['WATCHY_TIMESTAMP'] = str(int(time.time()))
                  
                  # Execute Zoom Nuitka binary
                  logger.info("‚ö° Executing Zoom monitoring binary...")
                  result = subprocess.run(
                      [binary_path],
                      env=env,
                      capture_output=True,
                      text=True,
                      timeout=240
                  )
                  
                  if result.returncode != 0:
                      raise Exception(f"Zoom binary failed: {result.stderr}")
                  
                  # Parse results
                  try:
                      lines = [line.strip() for line in result.stdout.split('\n') if line.strip()]
                      for line in reversed(lines):
                          if line.startswith('{') and line.endswith('}'):
                              output_data = json.loads(line)
                              break
                      else:
                          output_data = {"message": "Zoom monitoring completed", "stdout": result.stdout}
                  except:
                      output_data = {"message": "Zoom monitoring completed", "stdout": result.stdout}
                  
                  # Add metadata
                  output_data.update({
                      'saas_app': 'Zoom',
                      'binary_type': binary_info.get('binary_type', 'nuitka'),
                      'binary_version': binary_info.get('version'),
                      'binary_sha256': binary_info.get('sha256'),
                      'binary_size': binary_info.get('binarySize'),
                      'build_time': binary_info.get('buildTime'),
                      'git_commit': binary_info.get('gitCommit'),
                      'build_number': binary_info.get('buildNumber'),
                      'target_platform': binary_info.get('target_platform'),
                      'lambda_compatible': binary_info.get('lambda_compatible'),
                      'execution_time': time.time() - start_time,
                      'timestamp': datetime.utcnow().isoformat()
                  })
                  
                  logger.info("‚úÖ Zoom monitoring completed successfully")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(output_data)
                  }
                  
              except Exception as e:
                  error_msg = f"Zoom monitoring failed: {str(e)}"
                  logger.error(f"‚ùå {error_msg}")
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': error_msg,
                          'saas_app': 'Zoom',
                          'execution_time': time.time() - start_time
                      })
                  }

  # ===== ZOOM MONITORING SCHEDULE =====
  ZoomScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${ParentStackName}-ZoomSchedule'
      Description: 'Schedule for Zoom status monitoring'
      ScheduleExpression: !Ref MonitoringSchedule
      State: ENABLED
      Targets:
        - Arn: !GetAtt ZoomMonitoringLambda.Arn
          Id: ZoomMonitoringTarget

  ZoomLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt ZoomMonitoringLambda.Arn
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ZoomScheduleRule.Arn

  # ===== ZOOM CLOUDWATCH RESOURCES =====
  ZoomLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ZoomMonitoringLambda}'
      RetentionInDays: 30

  # Zoom Service Alarms
  ZoomAPIResponseAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-APIResponse'
      AlarmDescription: 'Zoom Status API response monitoring'
      MetricName: APIResponse
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 200
      ComparisonOperator: GreaterThanThreshold
      TreatMissingData: breaching
      AlarmActions:
        - !Ref NotificationTopicArn

  ZoomMeetingsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-Meetings'
      AlarmDescription: 'Zoom Meetings service status'
      MetricName: Meetings
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 2
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: ignore
      AlarmActions:
        - !Ref NotificationTopicArn

  ZoomWebinarsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-Webinars'
      AlarmDescription: 'Zoom Webinars service status'
      MetricName: Webinars
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 2
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: ignore
      AlarmActions:
        - !Ref NotificationTopicArn

  ZoomVideoAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-Video'
      AlarmDescription: 'Zoom Video service status'
      MetricName: Video
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 2
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: ignore
      AlarmActions:
        - !Ref NotificationTopicArn

  ZoomPhoneAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-Phone'
      AlarmDescription: 'Zoom Phone service status'
      MetricName: Phone
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 2
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: ignore
      AlarmActions:
        - !Ref NotificationTopicArn

  ZoomChatAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-Chat'
      AlarmDescription: 'Zoom Chat service status'
      MetricName: Chat
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 2
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: ignore
      AlarmActions:
        - !Ref NotificationTopicArn

  ZoomRoomsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-Zoom-Rooms'
      AlarmDescription: 'Zoom Rooms service status'
      MetricName: Rooms
      Namespace: Watchy/Zoom
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 2
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: ignore
      AlarmActions:
        - !Ref NotificationTopicArn

Outputs:
  LambdaFunctionName:
    Description: 'Zoom monitoring Lambda function name'
    Value: !Ref ZoomMonitoringLambda

  LambdaFunctionArn:
    Description: 'Zoom monitoring Lambda function ARN'
    Value: !GetAtt ZoomMonitoringLambda.Arn

  APIResponseAlarm:
    Description: 'Zoom API Response alarm ARN'
    Value: !GetAtt ZoomAPIResponseAlarm.Arn

  MeetingsAlarm:
    Description: 'Zoom Meetings alarm ARN'
    Value: !GetAtt ZoomMeetingsAlarm.Arn

  WebinarsAlarm:
    Description: 'Zoom Webinars alarm ARN'
    Value: !GetAtt ZoomWebinarsAlarm.Arn

  VideoAlarm:
    Description: 'Zoom Video alarm ARN'
    Value: !GetAtt ZoomVideoAlarm.Arn

  PhoneAlarm:
    Description: 'Zoom Phone alarm ARN'
    Value: !GetAtt ZoomPhoneAlarm.Arn

  ChatAlarm:
    Description: 'Zoom Chat alarm ARN'
    Value: !GetAtt ZoomChatAlarm.Arn

  RoomsAlarm:
    Description: 'Zoom Rooms alarm ARN'
    Value: !GetAtt ZoomRoomsAlarm.Arn
