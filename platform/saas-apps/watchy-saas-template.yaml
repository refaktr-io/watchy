AWSTemplateFormatVersion: '2010-09-09'
Description: 'Watchy SaaS App Monitoring - Standardized Nuitka Binary Template'

Parameters:
  # ===== REQUIRED STANDARDIZED PARAMETERS =====
  SaasAppName:
    Type: String
    Description: 'Name of the SaaS application (e.g., Slack, GitHub, Zoom)'
    AllowedPattern: '^[A-Za-z][A-Za-z0-9]*$'
    ConstraintDescription: 'Must start with a letter and contain only alphanumeric characters'

  ApiUrl:
    Type: String
    Description: 'Primary API endpoint for this SaaS app status monitoring'

  MonitoringSchedule:
    Type: String
    Description: 'Schedule expression for monitoring frequency (e.g., rate(5 minutes))'

  WatchyLicenseParameter:
    Type: String
    Description: 'ARN of the Watchy license parameter from parent stack'

  ApiKeysParameter:
    Type: String
    Description: 'ARN of the API keys parameter from parent stack'

  SharedLambdaRoleArn:
    Type: String
    Description: 'ARN of the shared Lambda execution role from parent stack'

  NotificationTopicArn:
    Type: String
    Description: 'ARN of the shared SNS topic for notifications'

  ParentStackName:
    Type: String
    Description: 'Name of the parent platform stack'

  BinaryDistributionUrl:
    Type: String
    Description: 'Base URL for Nuitka binary distribution'

  BinaryName:
    Type: String
    Description: 'Name of the Nuitka monitoring binary for this SaaS app'

  # ===== OPTIONAL CONFIGURATION PARAMETERS =====
  LogLevel:
    Type: String
    Default: 'INFO'
    AllowedValues: ['DEBUG', 'INFO', 'WARN', 'ERROR']
    Description: 'Log level for monitoring binary'

  TimeoutSeconds:
    Type: Number
    Default: 240
    MinValue: 30
    MaxValue: 900
    Description: 'Timeout for monitoring operations (includes binary download time)'

  RetryAttempts:
    Type: Number
    Default: 3
    MinValue: 1
    MaxValue: 10
    Description: 'Number of retry attempts for failed operations'

  MemorySize:
    Type: Number
    Default: 512
    AllowedValues: [128, 256, 512, 1024, 1536, 2048, 3008]
    Description: 'Lambda memory allocation (Nuitka binaries need more memory)'

Resources:
  # ===== LAMBDA FUNCTION FOR NUITKA BINARY EXECUTION =====
  MonitoringLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Architectures:
        - x86_64  # Required for Nuitka compiled binaries
      Description: !Sub 'Watchy ${SaasAppName} monitoring with Nuitka native binary'
      FunctionName: !Sub '${ParentStackName}-${SaasAppName}Monitor'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !Ref SharedLambdaRoleArn
      Timeout: 300  # Extra time for Nuitka binary download and execution
      MemorySize: !Ref MemorySize
      Environment:
        Variables:
          # SaaS App Configuration
          SAAS_APP_NAME: !Ref SaasAppName
          API_URL: !Ref ApiUrl
          CLOUDWATCH_NAMESPACE: !Sub 'Watchy/${SaasAppName}'
          
          # Watchy Platform Configuration
          WATCHY_LICENSE_PARAMETER: !Ref WatchyLicenseParameter
          API_KEYS_PARAMETER: !Ref ApiKeysParameter
          NOTIFICATION_TOPIC_ARN: !Ref NotificationTopicArn
          
          # Nuitka Binary Configuration
          WATCHY_BINARY_DISTRIBUTION_URL: !Ref BinaryDistributionUrl
          WATCHY_BINARY_NAME: !Ref BinaryName
          
          # Runtime Configuration
          WATCHY_LOG_LEVEL: !Ref LogLevel
          WATCHY_TIMEOUT_SECONDS: !Ref TimeoutSeconds
          WATCHY_RETRY_ATTEMPTS: !Ref RetryAttempts
          WATCHY_STACK_NAME: !Ref ParentStackName
          WATCHY_PLATFORM_VERSION: '4.0.0-nuitka'
      Code:
        ZipFile: !Sub |
          import json
          import subprocess
          import os
          import logging
          import urllib.request
          import time
          import hashlib
          import stat
          import boto3
          import gzip
          import tempfile
          from datetime import datetime
          from urllib.error import URLError, HTTPError

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(getattr(logging, os.environ.get('WATCHY_LOG_LEVEL', 'INFO')))

          # Global cache for binary management across warm starts
          _binary_cache = {}

          def get_nuitka_binary_info():
              """Get Nuitka binary download information from distribution API"""
              try:
                  base_url = os.environ.get('WATCHY_BINARY_DISTRIBUTION_URL')
                  binary_name = os.environ.get('WATCHY_BINARY_NAME')
                  saas_app = os.environ.get('SAAS_APP_NAME').lower()
                  
                  # Construct API URL for binary info
                  info_url = f"{base_url}/{saas_app}-monitor/latest/info"
                  
                  logger.info(f"Fetching binary info from: {info_url}")
                  
                  with urllib.request.urlopen(info_url, timeout=10) as response:
                      if response.status == 200:
                          data = json.loads(response.read().decode('utf-8'))
                          return {
                              'version': data.get('version'),
                              'download_url': data.get('download_url'),
                              'sha256': data.get('sha256'),
                              'size': data.get('size', 0),
                              'release_date': data.get('release_date'),
                              'compression': data.get('compression', 'gzip')
                          }
                      else:
                          logger.error(f"Binary info API returned status {response.status}")
                          return None
                          
              except (URLError, HTTPError) as e:
                  logger.error(f"Failed to fetch binary info: {e}")
                  return None
              except Exception as e:
                  logger.error(f"Unexpected error fetching binary info: {e}")
                  return None

          def download_nuitka_binary(binary_info):
              """Download and verify the Nuitka compiled binary"""
              try:
                  binary_name = os.environ.get('WATCHY_BINARY_NAME')
                  binary_path = f"/tmp/{binary_name}"
                  
                  logger.info(f"Downloading Nuitka binary version {binary_info['version']}...")
                  logger.info(f"Binary size: {binary_info.get('size', 'unknown')} bytes")
                  
                  # Download compressed binary
                  with urllib.request.urlopen(binary_info['download_url'], timeout=120) as response:
                      if response.status != 200:
                          raise Exception(f"Download failed: HTTP {response.status}")
                      
                      compressed_data = response.read()
                  
                  # Decompress if needed
                  if binary_info.get('compression') == 'gzip':
                      logger.info("Decompressing gzipped binary...")
                      binary_data = gzip.decompress(compressed_data)
                  else:
                      binary_data = compressed_data
                  
                  # Write binary to /tmp
                  with open(binary_path, 'wb') as f:
                      f.write(binary_data)
                  
                  # Make executable
                  os.chmod(binary_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
                  
                  # Verify SHA256 checksum if provided
                  if binary_info.get('sha256'):
                      actual_hash = hashlib.sha256(binary_data).hexdigest()
                      expected_hash = binary_info['sha256']
                      
                      if actual_hash != expected_hash:
                          os.remove(binary_path)
                          raise Exception(f"SHA256 checksum mismatch: expected {expected_hash}, got {actual_hash}")
                      
                      logger.info("‚úÖ Binary checksum verified successfully")
                  
                  logger.info(f"‚úÖ Nuitka binary downloaded and ready: {binary_path}")
                  return binary_path
                  
              except Exception as e:
                  logger.error(f"‚ùå Nuitka binary download failed: {e}")
                  raise

          def get_cached_binary_info():
              """Get information about currently cached binary"""
              try:
                  version_file = '/tmp/watchy-version.json'
                  if os.path.exists(version_file):
                      with open(version_file, 'r') as f:
                          return json.loads(f.read())
                  return None
              except Exception:
                  return None

          def cache_binary_info(binary_info):
              """Cache binary version information for future use"""
              try:
                  version_file = '/tmp/watchy-version.json'
                  cache_data = {
                      **binary_info,
                      'cached_at': time.time(),
                      'cache_date': datetime.utcnow().isoformat()
                  }
                  
                  with open(version_file, 'w') as f:
                      json.dump(cache_data, f, indent=2)
                      
              except Exception as e:
                  logger.warning(f"Failed to cache binary version info: {e}")

          def ensure_nuitka_binary():
              """Ensure we have the latest Nuitka binary available"""
              try:
                  binary_name = os.environ.get('WATCHY_BINARY_NAME')
                  binary_path = f"/tmp/{binary_name}"
                  
                  # Check global warm cache first (survives Lambda warm starts)
                  cache_key = binary_path
                  if cache_key in _binary_cache:
                      cached_info = _binary_cache[cache_key]
                      cache_age = time.time() - cached_info.get('check_time', 0)
                      
                      if os.path.exists(binary_path) and cache_age < 300:  # 5 minute cache
                          logger.info(f"Using warm-cached binary: {cached_info.get('version', 'unknown')}")
                          return binary_path, cached_info.get('version', 'cached')
                  
                  # Get latest binary information
                  latest_info = get_nuitka_binary_info()
                  if not latest_info:
                      # Fallback to existing binary if version check fails
                      if os.path.exists(binary_path):
                          logger.warning("‚ö†Ô∏è Using cached binary - version check failed")
                          return binary_path, 'cached-fallback'
                      else:
                          raise Exception("No binary available and download failed")
                  
                  # Check if we need to download new version
                  cached_info = get_cached_binary_info()
                  
                  if (cached_info and 
                      cached_info.get('version') == latest_info['version'] and 
                      os.path.exists(binary_path)):
                      logger.info(f"‚úÖ Binary up to date: {latest_info['version']}")
                  else:
                      # Download new version
                      logger.info(f"üîÑ Updating to latest version: {latest_info['version']}")
                      binary_path = download_nuitka_binary(latest_info)
                      cache_binary_info(latest_info)
                  
                  # Update global warm cache
                  _binary_cache[cache_key] = {
                      'version': latest_info['version'],
                      'check_time': time.time()
                  }
                  
                  return binary_path, latest_info['version']
                  
              except Exception as e:
                  logger.error(f"‚ùå Binary management failed: {e}")
                  
                  # Last resort: use any existing binary
                  if os.path.exists(binary_path):
                      logger.warning("‚ö†Ô∏è Using existing binary as emergency fallback")
                      return binary_path, 'emergency-fallback'
                  
                  raise Exception(f"No Nuitka binary available: {e}")

          def load_credentials():
              """Load credentials from Parameter Store"""
              try:
                  ssm = boto3.client('ssm')
                  
                  # Load license key
                  license_response = ssm.get_parameter(
                      Name=os.environ.get('WATCHY_LICENSE_PARAMETER'),
                      WithDecryption=True
                  )
                  license_key = license_response['Parameter']['Value']
                  
                  # Load API keys (JSON format)
                  api_keys_response = ssm.get_parameter(
                      Name=os.environ.get('API_KEYS_PARAMETER'),
                      WithDecryption=True
                  )
                  api_keys = json.loads(api_keys_response['Parameter']['Value'])
                  
                  return license_key, api_keys
                  
              except Exception as e:
                  logger.error(f"Failed to load credentials: {e}")
                  raise

          def lambda_handler(event, context):
              """Main Lambda handler for SaaS app monitoring with Nuitka binary"""
              start_time = time.time()
              saas_app = os.environ.get('SAAS_APP_NAME')
              
              try:
                  logger.info(f"üöÄ Starting {saas_app} monitoring with Nuitka binary...")
                  
                  # Ensure we have the latest Nuitka binary
                  binary_path, binary_version = ensure_nuitka_binary()
                  
                  setup_time = time.time() - start_time
                  logger.info(f"üì¶ Binary ready: {binary_version} (setup: {setup_time:.2f}s)")
                  
                  # Verify binary is executable
                  if not os.path.exists(binary_path):
                      raise Exception(f"Binary not found: {binary_path}")
                  
                  if not os.access(binary_path, os.X_OK):
                      raise Exception(f"Binary not executable: {binary_path}")
                  
                  # Load credentials from Parameter Store
                  license_key, api_keys = load_credentials()
                  
                  # Prepare environment variables for Nuitka binary
                  env = os.environ.copy()
                  env['WATCHY_LICENSE_KEY'] = license_key
                  
                  # Add SaaS-specific API credentials
                  saas_lower = saas_app.lower()
                  if saas_lower == 'github':
                      env['GITHUB_TOKEN'] = api_keys.get('github_token', '')
                  elif saas_lower == 'zoom':
                      env['ZOOM_API_KEY'] = api_keys.get('zoom_api_key', '')
                      env['ZOOM_API_SECRET'] = api_keys.get('zoom_api_secret', '')
                  elif saas_lower == 'slack':
                      env['SLACK_OAUTH_TOKEN'] = api_keys.get('slack_oauth_token', '')
                  
                  # Runtime metadata
                  env['WATCHY_AWS_REQUEST_ID'] = context.aws_request_id
                  env['WATCHY_FUNCTION_NAME'] = context.function_name
                  env['WATCHY_FUNCTION_VERSION'] = context.function_version
                  env['WATCHY_REMAINING_TIME_MS'] = str(context.get_remaining_time_in_millis())
                  env['WATCHY_TIMESTAMP'] = str(int(time.time()))
                  env['WATCHY_SAAS_APP'] = saas_app
                  
                  # Execute Nuitka binary
                  logger.info(f"‚ö° Executing {saas_app} Nuitka monitoring binary...")
                  
                  exec_start = time.time()
                  result = subprocess.run(
                      [binary_path],
                      env=env,
                      capture_output=True,
                      text=True,
                      timeout=int(os.environ.get('WATCHY_TIMEOUT_SECONDS', 240))
                  )
                  
                  exec_time = time.time() - exec_start
                  total_time = time.time() - start_time
                  
                  # Process execution results
                  if result.stdout:
                      logger.info(f"Binary stdout: {result.stdout}")
                  
                  if result.stderr:
                      logger.warning(f"Binary stderr: {result.stderr}")
                  
                  if result.returncode != 0:
                      raise Exception(f"Binary execution failed (code {result.returncode}): {result.stderr}")
                  
                  # Parse JSON output from Nuitka binary
                  try:
                      # Look for JSON in the last line of output
                      lines = [line.strip() for line in result.stdout.split('\n') if line.strip()]
                      output_data = None
                      
                      for line in reversed(lines):
                          if line.startswith('{') and line.endswith('}'):
                              output_data = json.loads(line)
                              break
                      
                      if not output_data:
                          output_data = {
                              "message": f"{saas_app} monitoring completed successfully",
                              "stdout": result.stdout
                          }
                  except Exception as e:
                      logger.warning(f"Failed to parse JSON output: {e}")
                      output_data = {
                          "message": f"{saas_app} monitoring completed successfully",
                          "stdout": result.stdout
                      }
                  
                  # Add execution metadata
                  output_data.update({
                      'saas_app': saas_app,
                      'binary_type': 'nuitka',
                      'binary_version': binary_version,
                      'setup_time': round(setup_time, 2),
                      'execution_time': round(exec_time, 2),
                      'total_time': round(total_time, 2),
                      'timestamp': datetime.utcnow().isoformat(),
                      'platform_version': '4.0.0-nuitka'
                  })
                  
                  logger.info(f"‚úÖ {saas_app} monitoring completed successfully (total: {total_time:.2f}s)")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(output_data)
                  }
                  
              except subprocess.TimeoutExpired:
                  error_msg = f"{saas_app} binary execution timed out"
                  logger.error(f"‚è∞ {error_msg}")
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': error_msg,
                          'saas_app': saas_app,
                          'execution_time': time.time() - start_time
                      })
                  }
              except Exception as e:
                  error_msg = f"{saas_app} monitoring failed: {str(e)}"
                  logger.error(f"‚ùå {error_msg}")
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': error_msg,
                          'saas_app': saas_app,
                          'execution_time': time.time() - start_time
                      })
                  }

  # ===== EVENTBRIDGE SCHEDULING =====
  MonitoringScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${ParentStackName}-${SaasAppName}Schedule'
      Description: !Sub 'Schedule for ${SaasAppName} monitoring with Nuitka binary'
      ScheduleExpression: !Ref MonitoringSchedule
      State: ENABLED
      Targets:
        - Arn: !GetAtt MonitoringLambdaFunction.Arn
          Id: !Sub '${SaasAppName}MonitoringTarget'

  # Lambda Permission for EventBridge
  MonitoringLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt MonitoringLambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt MonitoringScheduleRule.Arn

  # ===== CLOUDWATCH RESOURCES =====
  # CloudWatch Log Group
  MonitoringLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${MonitoringLambdaFunction}'
      RetentionInDays: 30

  # Primary Service Availability Alarm
  ServiceAvailabilityAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-${SaasAppName}-ServiceAvailability'
      AlarmDescription: !Sub 'Monitor ${SaasAppName} service availability via Nuitka binary'
      MetricName: ServiceStatus
      Namespace: !Sub 'Watchy/${SaasAppName}'
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 1
      ComparisonOperator: LessThanThreshold
      TreatMissingData: breaching
      AlarmActions:
        - !Ref NotificationTopicArn
      OKActions:
        - !Ref NotificationTopicArn

  # Binary Execution Health Alarm
  BinaryExecutionAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ParentStackName}-${SaasAppName}-BinaryExecution'
      AlarmDescription: !Sub 'Monitor ${SaasAppName} Nuitka binary execution health'
      MetricName: Errors
      Namespace: AWS/Lambda
      Dimensions:
        - Name: FunctionName
          Value: !Ref MonitoringLambdaFunction
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: notBreaching
      AlarmActions:
        - !Ref NotificationTopicArn

Outputs:
  # ===== FUNCTION OUTPUTS =====
  LambdaFunctionName:
    Description: !Sub '${SaasAppName} monitoring Lambda function name'
    Value: !Ref MonitoringLambdaFunction

  LambdaFunctionArn:
    Description: !Sub '${SaasAppName} monitoring Lambda function ARN'
    Value: !GetAtt MonitoringLambdaFunction.Arn

  ScheduleRuleName:
    Description: !Sub '${SaasAppName} monitoring schedule rule name'
    Value: !Ref MonitoringScheduleRule

  # ===== ALARM OUTPUTS =====
  ServiceAvailabilityAlarmArn:
    Description: !Sub '${SaasAppName} service availability alarm ARN'
    Value: !GetAtt ServiceAvailabilityAlarm.Arn

  BinaryExecutionAlarmArn:
    Description: !Sub '${SaasAppName} Nuitka binary execution alarm ARN'
    Value: !GetAtt BinaryExecutionAlarm.Arn

  # ===== METADATA OUTPUTS =====
  SaasAppName:
    Description: 'Name of the monitored SaaS application'
    Value: !Ref SaasAppName

  BinaryType:
    Description: 'Type of binary used for monitoring'
    Value: 'Nuitka'

  ApiUrl:
    Description: 'API endpoint being monitored'
    Value: !Ref ApiUrl
